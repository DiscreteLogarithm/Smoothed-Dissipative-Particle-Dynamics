diff -Naur lammps-13Aug16/src/USER-SDPD/fix_move_sph.cpp lammps-13Aug16-sdpd/src/USER-SDPD/fix_move_sph.cpp
--- lammps-13Aug16/src/USER-SDPD/fix_move_sph.cpp	1970-01-01 03:30:00.000000000 +0330
+++ lammps-13Aug16-sdpd/src/USER-SDPD/fix_move_sph.cpp	2016-05-23 20:30:21.809008000 +0430
@@ -0,0 +1,999 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "string.h"
+#include "stdlib.h"
+#include "math.h"
+#include "fix_move_sph.h"
+#include "atom.h"
+#include "group.h"
+#include "update.h"
+#include "modify.h"
+#include "force.h"
+#include "domain.h"
+#include "lattice.h"
+#include "comm.h"
+#include "input.h"
+#include "variable.h"
+#include "math_const.h"
+#include "memory.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+using namespace MathConst;
+
+enum{LINEAR,WIGGLE,ROTATE,VARIABLE};
+enum{EQUAL,ATOM};
+
+/* ---------------------------------------------------------------------- */
+
+FixMoveSPH::FixMoveSPH(LAMMPS *lmp, int narg, char **arg) :
+  Fix(lmp, narg, arg)
+{
+  if ((atom->e_flag != 1) || (atom->rho_flag != 1))
+    error->all(FLERR,
+        "fix meso command requires atom_style with both energy and density");
+
+  if (narg < 4) error->all(FLERR,"Illegal fix move command");
+
+  restart_global = 1;
+  restart_peratom = 1;
+  peratom_flag = 1;
+  size_peratom_cols = 3;
+  peratom_freq = 1;
+  time_integrate = 1;
+  create_attribute = 1;
+  displaceflag = 0;
+  velocityflag = 0;
+  maxatom = 0;
+
+  // parse args
+
+  int iarg;
+  xvarstr = yvarstr = zvarstr = NULL;
+  vxvarstr = vyvarstr = vzvarstr = NULL;
+
+  if (strcmp(arg[3],"linear") == 0) {
+    if (narg < 7) error->all(FLERR,"Illegal fix move command");
+    iarg = 7;
+    mstyle = LINEAR;
+    if (strcmp(arg[4],"NULL") == 0) vxflag = 0;
+    else {
+      vxflag = 1;
+      vx = force->numeric(FLERR,arg[4]);
+    }
+    if (strcmp(arg[5],"NULL") == 0) vyflag = 0;
+    else {
+      vyflag = 1;
+      vy = force->numeric(FLERR,arg[5]);
+    }
+    if (strcmp(arg[6],"NULL") == 0) vzflag = 0;
+    else {
+      vzflag = 1;
+      vz = force->numeric(FLERR,arg[6]);
+    }
+
+  } else if (strcmp(arg[3],"wiggle") == 0) {
+    if (narg < 8) error->all(FLERR,"Illegal fix move command");
+    iarg = 8;
+    mstyle = WIGGLE;
+    if (strcmp(arg[4],"NULL") == 0) axflag = 0;
+    else {
+      axflag = 1;
+      ax = force->numeric(FLERR,arg[4]);
+    }
+    if (strcmp(arg[5],"NULL") == 0) ayflag = 0;
+    else {
+      ayflag = 1;
+      ay = force->numeric(FLERR,arg[5]);
+    }
+    if (strcmp(arg[6],"NULL") == 0) azflag = 0;
+    else {
+      azflag = 1;
+      az = force->numeric(FLERR,arg[6]);
+    }
+    period = force->numeric(FLERR,arg[7]);
+
+  } else if (strcmp(arg[3],"rotate") == 0) {
+    if (narg < 11) error->all(FLERR,"Illegal fix move command");
+    iarg = 11;
+    mstyle = ROTATE;
+    point[0] = force->numeric(FLERR,arg[4]);
+    point[1] = force->numeric(FLERR,arg[5]);
+    point[2] = force->numeric(FLERR,arg[6]);
+    axis[0] = force->numeric(FLERR,arg[7]);
+    axis[1] = force->numeric(FLERR,arg[8]);
+    axis[2] = force->numeric(FLERR,arg[9]);
+    period = force->numeric(FLERR,arg[10]);
+
+  } else if (strcmp(arg[3],"variable") == 0) {
+    if (narg < 10) error->all(FLERR,"Illegal fix move command");
+    iarg = 10;
+    mstyle = VARIABLE;
+    if (strcmp(arg[4],"NULL") == 0) xvarstr = NULL;
+    else if (strstr(arg[4],"v_") == arg[4]) {
+      int n = strlen(&arg[4][2]) + 1;
+      xvarstr = new char[n];
+      strcpy(xvarstr,&arg[4][2]);
+    } else error->all(FLERR,"Illegal fix move command");
+    if (strcmp(arg[5],"NULL") == 0) yvarstr = NULL;
+    else if (strstr(arg[5],"v_") == arg[5]) {
+      int n = strlen(&arg[5][2]) + 1;
+      yvarstr = new char[n];
+      strcpy(yvarstr,&arg[5][2]);
+    } else error->all(FLERR,"Illegal fix move command");
+    if (strcmp(arg[6],"NULL") == 0) zvarstr = NULL;
+    else if (strstr(arg[6],"v_") == arg[6]) {
+      int n = strlen(&arg[6][2]) + 1;
+      zvarstr = new char[n];
+      strcpy(zvarstr,&arg[6][2]);
+    } else error->all(FLERR,"Illegal fix move command");
+    if (strcmp(arg[7],"NULL") == 0) vxvarstr = NULL;
+    else if (strstr(arg[7],"v_") == arg[7]) {
+      int n = strlen(&arg[7][2]) + 1;
+      vxvarstr = new char[n];
+      strcpy(vxvarstr,&arg[7][2]);
+    } else error->all(FLERR,"Illegal fix move command");
+    if (strcmp(arg[8],"NULL") == 0) vyvarstr = NULL;
+    else if (strstr(arg[8],"v_") == arg[8]) {
+      int n = strlen(&arg[8][2]) + 1;
+      vyvarstr = new char[n];
+      strcpy(vyvarstr,&arg[8][2]);
+    } else error->all(FLERR,"Illegal fix move command");
+    if (strcmp(arg[9],"NULL") == 0) vzvarstr = NULL;
+    else if (strstr(arg[9],"v_") == arg[9]) {
+      int n = strlen(&arg[9][2]) + 1;
+      vzvarstr = new char[n];
+      strcpy(vzvarstr,&arg[9][2]);
+    } else error->all(FLERR,"Illegal fix move command");
+
+  } else error->all(FLERR,"Illegal fix move command");
+
+  // optional args
+
+  int scaleflag = 1;
+
+  while (iarg < narg) {
+    if (strcmp(arg[iarg],"units") == 0) {
+      if (iarg+2 > narg) error->all(FLERR,"Illegal fix move command");
+      if (strcmp(arg[iarg+1],"box") == 0) scaleflag = 0;
+      else if (strcmp(arg[iarg+1],"lattice") == 0) scaleflag = 1;
+      else error->all(FLERR,"Illegal fix move command");
+      iarg += 2;
+    } else error->all(FLERR,"Illegal fix move command");
+  }
+
+  // error checks and warnings
+
+  if (domain->dimension == 2) {
+    if (mstyle == LINEAR && vzflag && vz != 0.0)
+      error->all(FLERR,"Fix move cannot set linear z motion for 2d problem");
+    if (mstyle == WIGGLE && azflag && az != 0.0)
+      error->all(FLERR,"Fix move cannot set wiggle z motion for 2d problem");
+    if (mstyle == ROTATE && (axis[0] != 0.0 || axis[1] != 0.0))
+      error->all(FLERR,
+                 "Fix move cannot rotate aroung non z-axis for 2d problem");
+    if (mstyle == VARIABLE && (zvarstr || vzvarstr))
+      error->all(FLERR,
+                 "Fix move cannot define z or vz variable for 2d problem");
+  }
+
+  if (atom->angmom_flag && comm->me == 0)
+    error->warning(FLERR,"Fix move does not update angular momentum");
+  if (atom->ellipsoid_flag && comm->me == 0)
+    error->warning(FLERR,"Fix move does not update quaternions");
+
+  // setup scaling and apply scaling factors to velocity & amplitude
+
+  if ((mstyle == LINEAR || mstyle == WIGGLE || mstyle == ROTATE) &&
+      scaleflag) {
+    double xscale = domain->lattice->xlattice;
+    double yscale = domain->lattice->ylattice;
+    double zscale = domain->lattice->zlattice;
+
+    if (mstyle == LINEAR) {
+      if (vxflag) vx *= xscale;
+      if (vyflag) vy *= yscale;
+      if (vzflag) vz *= zscale;
+    } else if (mstyle == WIGGLE) {
+      if (axflag) ax *= xscale;
+      if (ayflag) ay *= yscale;
+      if (azflag) az *= zscale;
+    } else if (mstyle == ROTATE) {
+      point[0] *= xscale;
+      point[1] *= yscale;
+      point[2] *= zscale;
+    }
+  }
+
+  // set omega_rotate from period
+
+  if (mstyle == WIGGLE || mstyle == ROTATE) omega_rotate = 2.0*MY_PI / period;
+
+  // runit = unit vector along rotation axis
+
+  if (mstyle == ROTATE) {
+    double len = sqrt(axis[0]*axis[0] + axis[1]*axis[1] + axis[2]*axis[2]);
+    if (len == 0.0)
+      error->all(FLERR,"Zero length rotation vector with fix move");
+    runit[0] = axis[0]/len;
+    runit[1] = axis[1]/len;
+    runit[2] = axis[2]/len;
+  }
+
+  // set omega_flag if particles store omega
+
+  omega_flag = atom->omega_flag;
+
+  // perform initial allocation of atom-based array
+  // register with Atom class
+
+  xoriginal = NULL;
+  grow_arrays(atom->nmax);
+  atom->add_callback(0);
+  atom->add_callback(1);
+
+  displace = velocity = NULL;
+
+  // xoriginal = initial unwrapped positions of atoms
+
+  double **x = atom->x;
+  imageint *image = atom->image;
+  int *mask = atom->mask;
+  int nlocal = atom->nlocal;
+
+  for (int i = 0; i < nlocal; i++) {
+    if (mask[i] & groupbit) domain->unmap(x[i],image[i],xoriginal[i]);
+    else xoriginal[i][0] = xoriginal[i][1] = xoriginal[i][2] = 0.0;
+  }
+
+  time_origin = update->ntimestep;
+}
+
+/* ---------------------------------------------------------------------- */
+
+FixMoveSPH::~FixMoveSPH()
+{
+  // unregister callbacks to this fix from Atom class
+
+  atom->delete_callback(id,0);
+  atom->delete_callback(id,1);
+
+  // delete locally stored arrays
+
+  memory->destroy(xoriginal);
+  memory->destroy(displace);
+  memory->destroy(velocity);
+
+  delete [] xvarstr;
+  delete [] yvarstr;
+  delete [] zvarstr;
+  delete [] vxvarstr;
+  delete [] vyvarstr;
+  delete [] vzvarstr;
+}
+
+/* ---------------------------------------------------------------------- */
+
+int FixMoveSPH::setmask()
+{
+  int mask = 0;
+  mask |= INITIAL_INTEGRATE;
+  mask |= FINAL_INTEGRATE;
+  mask |= PRE_FORCE;
+  return mask;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixMoveSPH::init()
+{
+  dt = update->dt;
+  dtv = update->dt;
+  dtf = 0.5 * update->dt * force->ftm2v;
+
+  // set indices and style of all variables
+
+  displaceflag = velocityflag = 0;
+
+  if (mstyle == VARIABLE) {
+    if (xvarstr) {
+      xvar = input->variable->find(xvarstr);
+      if (xvar < 0) error->all(FLERR,
+                               "Variable name for fix move does not exist");
+      if (input->variable->equalstyle(xvar)) xvarstyle = EQUAL;
+      else if (input->variable->atomstyle(xvar)) xvarstyle = ATOM;
+      else error->all(FLERR,"Variable for fix move is invalid style");
+    }
+    if (yvarstr) {
+      yvar = input->variable->find(yvarstr);
+      if (yvar < 0) error->all(FLERR,
+                               "Variable name for fix move does not exist");
+      if (input->variable->equalstyle(yvar)) yvarstyle = EQUAL;
+      else if (input->variable->atomstyle(yvar)) yvarstyle = ATOM;
+      else error->all(FLERR,"Variable for fix move is invalid style");
+    }
+    if (zvarstr) {
+      zvar = input->variable->find(zvarstr);
+      if (zvar < 0) error->all(FLERR,
+                               "Variable name for fix move does not exist");
+      if (input->variable->equalstyle(zvar)) zvarstyle = EQUAL;
+      else if (input->variable->atomstyle(zvar)) zvarstyle = ATOM;
+      else error->all(FLERR,"Variable for fix move is invalid style");
+    }
+    if (vxvarstr) {
+      vxvar = input->variable->find(vxvarstr);
+      if (vxvar < 0) error->all(FLERR,
+                                "Variable name for fix move does not exist");
+      if (input->variable->equalstyle(vxvar)) vxvarstyle = EQUAL;
+      else if (input->variable->atomstyle(vxvar)) vxvarstyle = ATOM;
+      else error->all(FLERR,"Variable for fix move is invalid style");
+    }
+    if (vyvarstr) {
+      vyvar = input->variable->find(vyvarstr);
+      if (vyvar < 0) error->all(FLERR,
+                                "Variable name for fix move does not exist");
+      if (input->variable->equalstyle(vyvar)) vyvarstyle = EQUAL;
+      else if (input->variable->atomstyle(vyvar)) vyvarstyle = ATOM;
+      else error->all(FLERR,"Variable for fix move is invalid style");
+    }
+    if (vzvarstr) {
+      vzvar = input->variable->find(vzvarstr);
+      if (vzvar < 0) error->all(FLERR,
+                                "Variable name for fix move does not exist");
+      if (input->variable->equalstyle(vzvar)) vzvarstyle = EQUAL;
+      else if (input->variable->atomstyle(vzvar)) vzvarstyle = ATOM;
+      else error->all(FLERR,"Variable for fix move is invalid style");
+    }
+
+    if (xvarstr && xvarstyle == ATOM) displaceflag = 1;
+    if (yvarstr && yvarstyle == ATOM) displaceflag = 1;
+    if (zvarstr && zvarstyle == ATOM) displaceflag = 1;
+    if (vxvarstr && vxvarstyle == ATOM) velocityflag = 1;
+    if (vyvarstr && vyvarstyle == ATOM) velocityflag = 1;
+    if (vzvarstr && vzvarstyle == ATOM) velocityflag = 1;
+  }
+
+  maxatom = atom->nmax;
+  memory->destroy(displace);
+  memory->destroy(velocity);
+  if (displaceflag) memory->create(displace,maxatom,3,"move:displace");
+  else displace = NULL;
+  if (velocityflag) memory->create(velocity,maxatom,3,"move:velocity");
+  else velocity = NULL;
+}
+
+void FixMoveSPH::setup_pre_force(int vflag)
+{
+  // set vest equal to v 
+  double **v = atom->v;
+  double **vest = atom->vest;
+  int *mask = atom->mask;
+  int nlocal = atom->nlocal;
+  if (igroup == atom->firstgroup)
+    nlocal = atom->nfirst;
+
+  for (int i = 0; i < nlocal; i++) {
+    if (mask[i] & groupbit) {
+      vest[i][0] = v[i][0];
+      vest[i][1] = v[i][1];
+      vest[i][2] = v[i][2];
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   set x,v of particles
+------------------------------------------------------------------------- */
+
+void FixMoveSPH::initial_integrate(int vflag)
+{
+  double dtfm;
+  double xold[3],a[3],b[3],c[3],d[3],disp[3],disp_next[3];
+  double ddotr,dx,dy,dz;
+
+  double delta = (update->ntimestep - time_origin) * dt;
+  double delta_next = (update->ntimestep - time_origin + 1) * dt;
+
+  double **x = atom->x;
+  double **v = atom->v;
+  double **vest = atom->vest;
+  double *rho = atom->rho;
+  double *drho = atom->drho;
+  double *e = atom->e;
+  double *de = atom->de;
+  double **f = atom->f;
+  double **omega = atom->omega;
+  double *rmass = atom->rmass;
+  double *mass = atom->mass;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  int nlocal = atom->nlocal;
+  int rmass_flag = atom->rmass_flag;
+
+  if (igroup == atom->firstgroup)
+    nlocal = atom->nfirst;
+
+  // for linear: X = X0 + V*dt
+
+  if (mstyle == LINEAR) {
+    for (int i = 0; i < nlocal; i++) {
+      if (mask[i] & groupbit) {
+        xold[0] = x[i][0];
+        xold[1] = x[i][1];
+        xold[2] = x[i][2];
+
+        e[i] += dtf * de[i]; // half-step update of particle internal energy
+        rho[i] += dtf * drho[i]; // ... and density
+
+        if (vxflag) {
+          vest[i][0] = v[i][0] = vx;
+          x[i][0] = xoriginal[i][0] + vx*delta;
+        } else {
+          dtfm = rmass_flag ? dtf / rmass[i] : dtf / mass[type[i]];
+          vest[i][0] = v[i][0] + 2.0 * dtfm * f[i][0];
+          v[i][0] += dtfm * f[i][0];
+          x[i][0] += dtv * v[i][0];
+        }
+
+        if (vyflag) {
+          vest[i][1] = v[i][1] = vy;
+          x[i][1] = xoriginal[i][1] + vy*delta;
+        } else {
+          dtfm = rmass_flag ? dtf / rmass[i] : dtf / mass[type[i]];
+          vest[i][1] = v[i][1] + 2.0 * dtfm * f[i][1];
+          v[i][1] += dtfm * f[i][1];
+          x[i][1] += dtv * v[i][1];
+        }
+
+        if (vzflag) {
+          vest[i][2] = v[i][2] = vz;
+          x[i][2] = xoriginal[i][2] + vz*delta;
+        } else {
+          dtfm = rmass_flag ? dtf / rmass[i] : dtf / mass[type[i]];
+          vest[i][2] = v[i][2] + 2.0 * dtfm * f[i][2];
+          v[i][2] += dtfm * f[i][2];
+          x[i][2] += dtv * v[i][2];
+        }
+
+        domain->remap_near(x[i],xold);
+      }
+    }
+
+  // for wiggle: X = X0 + A sin(w*dt)
+
+  } else if (mstyle == WIGGLE) {
+    double arg = omega_rotate * delta;
+    double arg_next = omega_rotate * delta_next;
+    double sine = sin(arg);
+    double cosine = cos(arg);
+    double sine_next = sin(arg_next);
+    double cosine_next = cos(arg_next);
+
+    for (int i = 0; i < nlocal; i++) {
+      if (mask[i] & groupbit) {
+        xold[0] = x[i][0];
+        xold[1] = x[i][1];
+        xold[2] = x[i][2];
+
+        e[i] += dtf * de[i]; // half-step update of particle internal energy
+        rho[i] += dtf * drho[i]; // ... and density
+
+        if (axflag) {
+          v[i][0] = ax*omega_rotate*cosine;
+          vest[i][0] = ax*omega_rotate*cosine_next;
+          x[i][0] = xoriginal[i][0] + ax*sine;
+        } else {
+          dtfm = rmass_flag ? dtf / rmass[i] : dtf / mass[type[i]];
+          vest[i][0] = v[i][0] + 2.0 * dtfm * f[i][0];
+          v[i][0] += dtfm * f[i][0];
+          x[i][0] += dtv * v[i][0];
+        }
+
+        if (ayflag) {
+          v[i][1] = ay*omega_rotate*cosine;
+          vest[i][1] = ay*omega_rotate*cosine_next;
+          x[i][1] = xoriginal[i][1] + ay*sine;
+        } else {
+          dtfm = rmass_flag ? dtf / rmass[i] : dtf / mass[type[i]];
+          vest[i][1] = v[i][1] + 2.0 * dtfm * f[i][1];
+          v[i][1] += dtfm * f[i][1];
+          x[i][1] += dtv * v[i][1];
+        }
+
+        if (azflag) {
+          v[i][2] = az*omega_rotate*cosine;
+          vest[i][2] = az*omega_rotate*cosine_next;
+          x[i][2] = xoriginal[i][2] + az*sine;
+        } else {
+          dtfm = rmass_flag ? dtf / rmass[i] : dtf / mass[type[i]];
+          vest[i][2] = v[i][2] + 2.0 * dtfm * f[i][2];
+          v[i][2] += dtfm * f[i][2];
+          x[i][2] += dtv * v[i][2];
+        }
+
+        domain->remap_near(x[i],xold);
+      }
+    }
+
+  // for rotate by right-hand rule around omega:
+  // P = point = vector = point of rotation
+  // R = vector = axis of rotation
+  // w = omega of rotation (from period)
+  // X0 = xoriginal = initial coord of atom
+  // R0 = runit = unit vector for R
+  // D = X0 - P = vector from P to X0
+  // C = (D dot R0) R0 = projection of atom coord onto R line
+  // A = D - C = vector from R line to X0
+  // B = R0 cross A = vector perp to A in plane of rotation
+  // A,B define plane of circular rotation around R line
+  // X = P + C + A cos(w*dt) + B sin(w*dt)
+  // V = w R0 cross (A cos(w*dt) + B sin(w*dt))
+
+  } else if (mstyle == ROTATE) {
+    double arg = omega_rotate * delta;
+    double arg_next = omega_rotate * delta_next;
+    double sine = sin(arg);
+    double cosine = cos(arg);
+    double sine_next = sin(arg_next);
+    double cosine_next = cos(arg_next);
+
+    for (int i = 0; i < nlocal; i++) {
+      if (mask[i] & groupbit) {
+        xold[0] = x[i][0];
+        xold[1] = x[i][1];
+        xold[2] = x[i][2];
+
+        e[i] += dtf * de[i]; // half-step update of particle internal energy
+        rho[i] += dtf * drho[i]; // ... and density
+
+        d[0] = xoriginal[i][0] - point[0];
+        d[1] = xoriginal[i][1] - point[1];
+        d[2] = xoriginal[i][2] - point[2];
+        ddotr = d[0]*runit[0] + d[1]*runit[1] + d[2]*runit[2];
+        c[0] = ddotr*runit[0];
+        c[1] = ddotr*runit[1];
+        c[2] = ddotr*runit[2];
+        a[0] = d[0] - c[0];
+        a[1] = d[1] - c[1];
+        a[2] = d[2] - c[2];
+        b[0] = runit[1]*a[2] - runit[2]*a[1];
+        b[1] = runit[2]*a[0] - runit[0]*a[2];
+        b[2] = runit[0]*a[1] - runit[1]*a[0];
+        disp[0] = a[0]*cosine  + b[0]*sine;
+        disp[1] = a[1]*cosine  + b[1]*sine;
+        disp[2] = a[2]*cosine  + b[2]*sine;
+        disp_next[0] = a[0]*cosine_next  + b[0]*sine_next;
+        disp_next[1] = a[1]*cosine_next  + b[1]*sine_next;
+        disp_next[2] = a[2]*cosine_next  + b[2]*sine_next;
+
+        x[i][0] = point[0] + c[0] + disp[0];
+        x[i][1] = point[1] + c[1] + disp[1];
+        x[i][2] = point[2] + c[2] + disp[2];
+        v[i][0] = omega_rotate * (runit[1]*disp[2] - runit[2]*disp[1]);
+        v[i][1] = omega_rotate * (runit[2]*disp[0] - runit[0]*disp[2]);
+        v[i][2] = omega_rotate * (runit[0]*disp[1] - runit[1]*disp[0]);
+        vest[i][0] = omega_rotate * (runit[1]*disp_next[2] - runit[2]*disp_next[1]);
+        vest[i][1] = omega_rotate * (runit[2]*disp_next[0] - runit[0]*disp_next[2]);
+        vest[i][2] = omega_rotate * (runit[0]*disp_next[1] - runit[1]*disp_next[0]);
+        if (omega_flag) {
+          omega[i][0] = omega_rotate*runit[0];
+          omega[i][1] = omega_rotate*runit[1];
+          omega[i][2] = omega_rotate*runit[2];
+        }
+
+        domain->remap_near(x[i],xold);
+      }
+    }
+
+  // for variable: compute x,v from variables
+
+  } else if (mstyle == VARIABLE) {
+
+    // reallocate displace and velocity arrays as necessary
+
+    if ((displaceflag || velocityflag) && nlocal > maxatom) {
+      maxatom = atom->nmax;
+      if (displaceflag) {
+        memory->destroy(displace);
+        memory->create(displace,maxatom,3,"move:displace");
+      }
+      if (velocityflag) {
+        memory->destroy(velocity);
+        memory->create(velocity,maxatom,3,"move:velocity");
+      }
+    }
+
+    // pre-compute variable values, wrap with clear/add
+
+    modify->clearstep_compute();
+
+    if (xvarstr) {
+      if (xvarstyle == EQUAL) dx = input->variable->compute_equal(xvar);
+      else input->variable->compute_atom(xvar,igroup,&displace[0][0],3,0);
+    }
+    if (yvarstr) {
+      if (yvarstyle == EQUAL) dy = input->variable->compute_equal(yvar);
+      else input->variable->compute_atom(yvar,igroup,&displace[0][1],3,0);
+    }
+    if (zvarstr) {
+      if (zvarstyle == EQUAL) dz = input->variable->compute_equal(zvar);
+      else input->variable->compute_atom(zvar,igroup,&displace[0][2],3,0);
+    }
+    if (vxvarstr) {
+      if (vxvarstyle == EQUAL) vx = input->variable->compute_equal(vxvar);
+      else input->variable->compute_atom(vxvar,igroup,&velocity[0][0],3,0);
+    }
+    if (vyvarstr) {
+      if (vyvarstyle == EQUAL) vy = input->variable->compute_equal(vyvar);
+      else input->variable->compute_atom(vyvar,igroup,&velocity[0][1],3,0);
+    }
+    if (vzvarstr) {
+      if (vzvarstyle == EQUAL) vz = input->variable->compute_equal(vzvar);
+      else input->variable->compute_atom(vzvar,igroup,&velocity[0][2],3,0);
+    }
+
+    modify->addstep_compute(update->ntimestep + 1);
+
+    // update x,v
+    // vest (velocity in next step) could be different from v in the next
+    // step, but this is the nest we could do
+
+    for (int i = 0; i < nlocal; i++) {
+      if (mask[i] & groupbit) {
+        xold[0] = x[i][0];
+        xold[1] = x[i][1];
+        xold[2] = x[i][2];
+
+        if (xvarstr && vxvarstr) {
+          if (vxvarstyle == EQUAL) vest[i][0] = v[i][0] = vx;
+          else vest[i][0] = v[i][0] = velocity[i][0];
+          if (xvarstyle == EQUAL) x[i][0] = xoriginal[i][0] + dx;
+          else x[i][0] = xoriginal[i][0] + displace[i][0];
+        } else if (xvarstr) {
+          if (xvarstyle == EQUAL) x[i][0] = xoriginal[i][0] + dx;
+          else x[i][0] = xoriginal[i][0] + displace[i][0];
+        } else if (vxvarstr) {
+          if (vxvarstyle == EQUAL) vest[i][0] = v[i][0] = vx;
+          else vest[i][0] = v[i][0] = velocity[i][0];
+          x[i][0] += dtv * v[i][0];
+        } else {
+          dtfm = rmass_flag ? dtf / rmass[i] : dtf / mass[type[i]];
+          vest[i][0] = v[i][0] + 2.0 * dtfm * f[i][0];
+          v[i][0] += dtfm * f[i][0];
+          x[i][0] += dtv * v[i][0];
+        }
+
+        if (yvarstr && vyvarstr) {
+          if (vyvarstyle == EQUAL) vest[i][1] = v[i][1] = vy;
+          else vest[i][1] = v[i][1] = velocity[i][1];
+          if (yvarstyle == EQUAL) x[i][1] = xoriginal[i][1] + dy;
+          else x[i][1] = xoriginal[i][1] + displace[i][1];
+        } else if (yvarstr) {
+          if (yvarstyle == EQUAL) x[i][1] = xoriginal[i][1] + dy;
+          else x[i][1] = xoriginal[i][1] + displace[i][1];
+        } else if (vyvarstr) {
+          if (vyvarstyle == EQUAL) vest[i][1] = v[i][1] = vy;
+          else vest[i][1] = v[i][1] = velocity[i][1];
+          x[i][1] += dtv * v[i][1];
+        } else {
+          dtfm = rmass_flag ? dtf / rmass[i] : dtf / mass[type[i]];
+          vest[i][1] = v[i][1] + 2.0 * dtfm * f[i][1];
+          v[i][1] += dtfm * f[i][1];
+          x[i][1] += dtv * v[i][1];
+        }
+
+        if (zvarstr && vzvarstr) {
+          if (vzvarstyle == EQUAL) vest[i][2] = v[i][2] = vz;
+          else vest[i][2] = v[i][2] = velocity[i][2];
+          if (zvarstyle == EQUAL) x[i][2] = xoriginal[i][2] + dz;
+          else x[i][2] = xoriginal[i][2] + displace[i][2];
+        } else if (zvarstr) {
+          if (zvarstyle == EQUAL) x[i][2] = xoriginal[i][2] + dz;
+          else x[i][2] = xoriginal[i][2] + displace[i][2];
+        } else if (vzvarstr) {
+          if (vzvarstyle == EQUAL) vest[i][2] = v[i][2] = vz;
+          else vest[i][2] = v[i][2] = velocity[i][2];
+          x[i][2] += dtv * v[i][2];
+        } else {
+          dtfm = rmass_flag ? dtf / rmass[i] : dtf / mass[type[i]];
+          vest[i][2] = v[i][2] + 2.0 * dtfm * f[i][2];
+          v[i][2] += dtfm * f[i][2];
+          x[i][2] += dtv * v[i][2];
+        }
+
+        domain->remap_near(x[i],xold);
+      }
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   final NVE of particles with NULL components
+------------------------------------------------------------------------- */
+
+void FixMoveSPH::final_integrate()
+{
+  double dtfm;
+
+  int xflag = 1;
+  if (mstyle == LINEAR && vxflag) xflag = 0;
+  else if (mstyle == WIGGLE && axflag) xflag = 0;
+  else if (mstyle == ROTATE) xflag = 0;
+  else if (mstyle == VARIABLE && (xvarstr || vxvarstr)) xflag = 0;
+
+  int yflag = 1;
+  if (mstyle == LINEAR && vyflag) yflag = 0;
+  else if (mstyle == WIGGLE && ayflag) yflag = 0;
+  else if (mstyle == ROTATE) yflag = 0;
+  else if (mstyle == VARIABLE && (yvarstr || vyvarstr)) yflag = 0;
+
+  int zflag = 1;
+  if (mstyle == LINEAR && vzflag) zflag = 0;
+  else if (mstyle == WIGGLE && azflag) zflag = 0;
+  else if (mstyle == ROTATE) zflag = 0;
+  else if (mstyle == VARIABLE && (zvarstr || vzvarstr)) zflag = 0;
+
+  double **v = atom->v;
+  double **f = atom->f;
+  double *e = atom->e;
+  double *de = atom->de;
+  double *rho = atom->rho;
+  double *drho = atom->drho;
+  double *rmass = atom->rmass;
+  double *mass = atom->mass;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  int nlocal = atom->nlocal;
+  int rmass_flag = atom->rmass_flag;
+
+  if (igroup == atom->firstgroup)
+    nlocal = atom->nfirst;
+
+  for (int i = 0; i < nlocal; i++) {
+    if (mask[i] & groupbit) {
+      e[i] += dtf * de[i];
+      rho[i] += dtf * drho[i];
+
+      if (xflag) {
+        dtfm = rmass_flag ? dtf / rmass[i] : dtf / mass[type[i]];
+        v[i][0] += dtfm * f[i][0];
+      }
+
+      if (yflag) {
+        dtfm = rmass_flag ? dtf / rmass[i] : dtf / mass[type[i]];
+        v[i][1] += dtfm * f[i][1];
+      }
+
+      if (zflag) {
+        dtfm = rmass_flag ? dtf / rmass[i] : dtf / mass[type[i]];
+        v[i][2] += dtfm * f[i][2];
+      }
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   memory usage of local atom-based array
+------------------------------------------------------------------------- */
+
+double FixMoveSPH::memory_usage()
+{
+  double bytes = atom->nmax*3 * sizeof(double);
+  if (displaceflag) bytes += atom->nmax*3 * sizeof(double);
+  if (velocityflag) bytes += atom->nmax*3 * sizeof(double);
+  return bytes;
+}
+
+/* ----------------------------------------------------------------------
+   pack entire state of Fix into one write
+------------------------------------------------------------------------- */
+
+void FixMoveSPH::write_restart(FILE *fp)
+{
+  int n = 0;
+  double list[1];
+  list[n++] = time_origin;
+
+  if (comm->me == 0) {
+    int size = n * sizeof(double);
+    fwrite(&size,sizeof(int),1,fp);
+    fwrite(list,sizeof(double),n,fp);
+  }
+}
+
+/* ----------------------------------------------------------------------
+   use state info from restart file to restart the Fix
+------------------------------------------------------------------------- */
+
+void FixMoveSPH::restart(char *buf)
+{
+  int n = 0;
+  double *list = (double *) buf;
+
+  time_origin = static_cast<int> (list[n++]);
+}
+
+/* ----------------------------------------------------------------------
+   allocate atom-based array
+------------------------------------------------------------------------- */
+
+void FixMoveSPH::grow_arrays(int nmax)
+{
+  memory->grow(xoriginal,nmax,3,"move:xoriginal");
+  array_atom = xoriginal;
+}
+
+/* ----------------------------------------------------------------------
+   copy values within local atom-based array
+------------------------------------------------------------------------- */
+
+void FixMoveSPH::copy_arrays(int i, int j, int delflag)
+{
+  xoriginal[j][0] = xoriginal[i][0];
+  xoriginal[j][1] = xoriginal[i][1];
+  xoriginal[j][2] = xoriginal[i][2];
+}
+
+/* ----------------------------------------------------------------------
+   initialize one atom's array values, called when atom is created
+------------------------------------------------------------------------- */
+
+void FixMoveSPH::set_arrays(int i)
+{
+  double **x = atom->x;
+  imageint *image = atom->image;
+  int *mask = atom->mask;
+
+  // particle not in group
+
+  if (!(mask[i] & groupbit)) {
+    xoriginal[i][0] = xoriginal[i][1] = xoriginal[i][2] = 0.0;
+    return;
+  }
+
+  // current time still equal fix creation time
+
+  if (update->ntimestep == time_origin) {
+    domain->unmap(x[i],image[i],xoriginal[i]);
+    return;
+  }
+
+  // backup particle to time_origin
+
+  if (mstyle == VARIABLE)
+    error->all(FLERR,"Cannot add atoms to fix move variable");
+
+  domain->unmap(x[i],image[i],xoriginal[i]);
+  double delta = (update->ntimestep - time_origin) * update->dt;
+
+  if (mstyle == LINEAR) {
+    if (vxflag) xoriginal[i][0] -= vx * delta;
+    if (vyflag) xoriginal[i][1] -= vy * delta;
+    if (vzflag) xoriginal[i][2] -= vz * delta;
+  } else if (mstyle == WIGGLE) {
+    double arg = omega_rotate * delta;
+    double sine = sin(arg);
+    if (axflag) xoriginal[i][0] -= ax*sine;
+    if (ayflag) xoriginal[i][1] -= ay*sine;
+    if (azflag) xoriginal[i][2] -= az*sine;
+  } else if (mstyle == ROTATE) {
+    double a[3],b[3],c[3],d[3],disp[3],ddotr;
+    double arg = - omega_rotate * delta;
+    double sine = sin(arg);
+    double cosine = cos(arg);
+    d[0] = x[i][0] - point[0];
+    d[1] = x[i][1] - point[1];
+    d[2] = x[i][2] - point[2];
+    ddotr = d[0]*runit[0] + d[1]*runit[1] + d[2]*runit[2];
+    c[0] = ddotr*runit[0];
+    c[1] = ddotr*runit[1];
+    c[2] = ddotr*runit[2];
+
+    a[0] = d[0] - c[0];
+    a[1] = d[1] - c[1];
+    a[2] = d[2] - c[2];
+    b[0] = runit[1]*a[2] - runit[2]*a[1];
+    b[1] = runit[2]*a[0] - runit[0]*a[2];
+    b[2] = runit[0]*a[1] - runit[1]*a[0];
+    disp[0] = a[0]*cosine  + b[0]*sine;
+    disp[1] = a[1]*cosine  + b[1]*sine;
+    disp[2] = a[2]*cosine  + b[2]*sine;
+
+    xoriginal[i][0] = point[0] + c[0] + disp[0];
+    xoriginal[i][1] = point[1] + c[1] + disp[1];
+    xoriginal[i][2] = point[2] + c[2] + disp[2];
+  }
+}
+
+/* ----------------------------------------------------------------------
+   pack values in local atom-based array for exchange with another proc
+------------------------------------------------------------------------- */
+
+int FixMoveSPH::pack_exchange(int i, double *buf)
+{
+  buf[0] = xoriginal[i][0];
+  buf[1] = xoriginal[i][1];
+  buf[2] = xoriginal[i][2];
+  return 3;
+}
+
+/* ----------------------------------------------------------------------
+   unpack values in local atom-based array from exchange with another proc
+------------------------------------------------------------------------- */
+
+int FixMoveSPH::unpack_exchange(int nlocal, double *buf)
+{
+  xoriginal[nlocal][0] = buf[0];
+  xoriginal[nlocal][1] = buf[1];
+  xoriginal[nlocal][2] = buf[2];
+  return 3;
+}
+
+/* ----------------------------------------------------------------------
+   pack values in local atom-based arrays for restart file
+------------------------------------------------------------------------- */
+
+int FixMoveSPH::pack_restart(int i, double *buf)
+{
+  buf[0] = 4;
+  buf[1] = xoriginal[i][0];
+  buf[2] = xoriginal[i][1];
+  buf[3] = xoriginal[i][2];
+  return 4;
+}
+
+/* ----------------------------------------------------------------------
+   unpack values from atom->extra array to restart the fix
+------------------------------------------------------------------------- */
+
+void FixMoveSPH::unpack_restart(int nlocal, int nth)
+{
+  double **extra = atom->extra;
+
+  // skip to Nth set of extra values
+
+  int m = 0;
+  for (int i = 0; i < nth; i++) m += static_cast<int> (extra[nlocal][m]);
+  m++;
+
+  xoriginal[nlocal][0] = extra[nlocal][m++];
+  xoriginal[nlocal][1] = extra[nlocal][m++];
+  xoriginal[nlocal][2] = extra[nlocal][m++];
+}
+
+/* ----------------------------------------------------------------------
+   maxsize of any atom's restart data
+------------------------------------------------------------------------- */
+
+int FixMoveSPH::maxsize_restart()
+{
+  return 4;
+}
+
+/* ----------------------------------------------------------------------
+   size of atom nlocal's restart data
+------------------------------------------------------------------------- */
+
+int FixMoveSPH::size_restart(int nlocal)
+{
+  return 4;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixMoveSPH::reset_dt()
+{
+  error->all(FLERR,"Resetting timestep size is not allowed with fix move");
+}
diff -Naur lammps-13Aug16/src/USER-SDPD/fix_move_sph.h lammps-13Aug16-sdpd/src/USER-SDPD/fix_move_sph.h
--- lammps-13Aug16/src/USER-SDPD/fix_move_sph.h	1970-01-01 03:30:00.000000000 +0330
+++ lammps-13Aug16-sdpd/src/USER-SDPD/fix_move_sph.h	2016-05-23 20:30:21.810008000 +0430
@@ -0,0 +1,129 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+
+FixStyle(move/sph,FixMoveSPH)
+
+#else
+
+#ifndef LMP_FIX_MOVE_SPH_H
+#define LMP_FIX_MOVE_SPH_H
+
+#include "stdio.h"
+#include "fix.h"
+
+namespace LAMMPS_NS {
+
+class FixMoveSPH : public Fix {
+ public:
+  FixMoveSPH(class LAMMPS *, int, char **);
+  ~FixMoveSPH();
+  int setmask();
+  void init();
+  void setup_pre_force(int);
+  void initial_integrate(int);
+  void final_integrate();
+
+  double memory_usage();
+  void write_restart(FILE *);
+  void restart(char *);
+  void grow_arrays(int);
+  void copy_arrays(int, int, int);
+  void set_arrays(int);
+  int pack_exchange(int, double *);
+  int unpack_exchange(int, double *);
+  int pack_restart(int, double *);
+  void unpack_restart(int, int);
+  int maxsize_restart();
+  int size_restart(int);
+
+  void reset_dt();
+
+ private:
+  char *xvarstr,*yvarstr,*zvarstr,*vxvarstr,*vyvarstr,*vzvarstr;
+  int mstyle;
+  int vxflag,vyflag,vzflag,axflag,ayflag,azflag;
+  double vx,vy,vz,ax,ay,az;
+  double period,omega_rotate;
+  double point[3],axis[3],runit[3];
+  double dt,dtv,dtf;
+  int xvar,yvar,zvar,vxvar,vyvar,vzvar;
+  int xvarstyle,yvarstyle,zvarstyle,vxvarstyle,vyvarstyle,vzvarstyle;
+  int omega_flag,nlevels_respa;
+  int time_origin;
+
+  double **xoriginal;         // original coords of atoms
+  int displaceflag,velocityflag;
+  int maxatom;
+  double **displace,**velocity;
+};
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Illegal ... command
+
+Self-explanatory.  Check the input script syntax and compare to the
+documentation for the command.  You can use -echo screen as a
+command-line option when running LAMMPS to see the offending line.
+
+E: Fix move cannot set linear z motion for 2d problem
+
+Self-explanatory.
+
+E: Fix move cannot set wiggle z motion for 2d problem
+
+Self-explanatory.
+
+E: Fix move cannot rotate aroung non z-axis for 2d problem
+
+Self-explanatory.
+
+E: Fix move cannot define z or vz variable for 2d problem
+
+Self-explanatory.
+
+W: Fix move does not update angular momentum
+
+Atoms store this quantity, but fix move does not (yet) update it.
+
+W: Fix move does not update quaternions
+
+Atoms store this quantity, but fix move does not (yet) update it.
+
+E: Zero length rotation vector with fix move
+
+Self-explanatory.
+
+E: Variable name for fix move does not exist
+
+Self-explanatory.
+
+E: Variable for fix move is invalid style
+
+Only equal-style variables can be used.
+
+E: Cannot add atoms to fix move variable
+
+Atoms can not be added afterwards to this fix option.
+
+E: Resetting timestep size is not allowed with fix move
+
+This is because fix move is moving atoms based on elapsed time.
+
+*/
diff -Naur lammps-13Aug16/src/USER-SDPD/fix_rigid_sph.cpp lammps-13Aug16-sdpd/src/USER-SDPD/fix_rigid_sph.cpp
--- lammps-13Aug16/src/USER-SDPD/fix_rigid_sph.cpp	1970-01-01 03:30:00.000000000 +0330
+++ lammps-13Aug16-sdpd/src/USER-SDPD/fix_rigid_sph.cpp	2016-09-15 11:25:44.497412000 +0430
@@ -0,0 +1,544 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing authors:
+      Morteza Jalalvand         jalalvand.m AT iasbs.ac.ir
+      Mohammad Charsooghi       charsooghi AT iasbs.ac.ir
+      Sarah Mohammadinejad      sarah AT iasbs.ac.ir
+    
+    This is an extension of fix/rigid/nve to SPH particles
+    You can see copyright notice of fix/rigid/nve authors bellow
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Tony Sheh (U Michigan), Trung Dac Nguyen (U Michigan)
+   references: Kamberaj et al., J. Chem. Phys. 122, 224114 (2005)
+               Miller et al., J Chem Phys. 116, 8649-8659 (2002)
+------------------------------------------------------------------------- */
+
+#include <math.h>
+#include <stdio.h>
+#include <string.h>
+#include "fix_rigid_sph.h"
+#include "math_extra.h"
+#include "atom.h"
+#include "compute.h"
+#include "domain.h"
+#include "update.h"
+#include "modify.h"
+#include "fix_deform.h"
+#include "group.h"
+#include "comm.h"
+#include "force.h"
+#include "kspace.h"
+#include "output.h"
+#include "memory.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+
+#define EPSILON 1.0e-7
+
+/* ---------------------------------------------------------------------- */
+
+FixRigidSPH::FixRigidSPH (LAMMPS *lmp, int narg, char **arg) :
+  FixRigid (lmp, narg, arg) {
+  if ((atom->e_flag != 1) || (atom->rho_flag != 1))
+    error->all (FLERR, "fix rigid/sph command requires atom_style with"
+                       " both energy and density");
+  
+  if (langflag || tstat_flag)
+    error->all (FLERR,"Can not use thermostat with fix rigid/sph");
+  
+  if (pstat_flag)
+    error->all (FLERR,"Can not use barostat with fix rigid/sph");
+
+  // memory allocation and initialization
+
+  memory->create(conjqm,nbody,4,"rigid_nh:conjqm");
+}
+
+/* ---------------------------------------------------------------------- */
+
+FixRigidSPH::~FixRigidSPH() {
+  memory->destroy(conjqm);
+}
+
+/* ---------------------------------------------------------------------- */
+
+int FixRigidSPH::setmask() {
+  int mask = 0;
+  mask |= INITIAL_INTEGRATE;
+  mask |= FINAL_INTEGRATE;
+  mask |= PRE_NEIGHBOR;
+  return mask;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidSPH::setup(int vflag) {
+  FixRigid::setup(vflag);
+
+  double mbody[3];
+  for (int ibody = 0; ibody < nbody; ibody++) {
+    MathExtra::transpose_matvec (ex_space[ibody],ey_space[ibody],ez_space[ibody],
+                                 angmom[ibody],mbody);
+    MathExtra::quatvec (quat[ibody],mbody,conjqm[ibody]);
+    conjqm[ibody][0] *= 2.0;
+    conjqm[ibody][1] *= 2.0;
+    conjqm[ibody][2] *= 2.0;
+    conjqm[ibody][3] *= 2.0;
+  }
+}
+
+/* ----------------------------------------------------------------------
+   perform preforce velocity Verlet integration
+   see Kamberaj paper for step references
+------------------------------------------------------------------------- */
+
+void FixRigidSPH::initial_integrate(int vflag) {
+  double dtfm,mbody[3],tbody[3],fquat[4];
+  double dtf2 = dtf * 2.0;
+
+  // update xcm, vcm, quat, conjqm and angmom
+
+  for (int ibody = 0; ibody < nbody; ibody++) {
+
+    // step 1.1 - update vcm by 1/2 step
+
+    dtfm = dtf / masstotal[ibody];
+    vcm[ibody][0] += dtfm * fcm[ibody][0] * fflag[ibody][0];
+    vcm[ibody][1] += dtfm * fcm[ibody][1] * fflag[ibody][1];
+    vcm[ibody][2] += dtfm * fcm[ibody][2] * fflag[ibody][2];
+
+    // step 1.2 - update xcm by full step
+
+    xcm[ibody][0] += dtv * vcm[ibody][0];
+    xcm[ibody][1] += dtv * vcm[ibody][1];
+    xcm[ibody][2] += dtv * vcm[ibody][2];
+
+    // step 1.3 - apply torque (body coords) to quaternion momentum
+
+    torque[ibody][0] *= tflag[ibody][0];
+    torque[ibody][1] *= tflag[ibody][1];
+    torque[ibody][2] *= tflag[ibody][2];
+
+    MathExtra::transpose_matvec (ex_space[ibody],ey_space[ibody],ez_space[ibody],
+                                 torque[ibody],tbody);
+    MathExtra::quatvec (quat[ibody],tbody,fquat);
+
+    conjqm[ibody][0] += dtf2 * fquat[0];
+    conjqm[ibody][1] += dtf2 * fquat[1];
+    conjqm[ibody][2] += dtf2 * fquat[2];
+    conjqm[ibody][3] += dtf2 * fquat[3];
+
+    // step 1.4 to 1.13 - use no_squish rotate to update p and q
+
+    MathExtra::no_squish_rotate (3,conjqm[ibody],quat[ibody],inertia[ibody],dtq);
+    MathExtra::no_squish_rotate (2,conjqm[ibody],quat[ibody],inertia[ibody],dtq);
+    MathExtra::no_squish_rotate (1,conjqm[ibody],quat[ibody],inertia[ibody],dtv);
+    MathExtra::no_squish_rotate (2,conjqm[ibody],quat[ibody],inertia[ibody],dtq);
+    MathExtra::no_squish_rotate (3,conjqm[ibody],quat[ibody],inertia[ibody],dtq);
+
+    // update exyz_space
+    // transform p back to angmom
+    // update angular velocity
+
+    MathExtra::q_to_exyz (quat[ibody],ex_space[ibody],ey_space[ibody],
+                          ez_space[ibody]);
+    MathExtra::invquatvec (quat[ibody],conjqm[ibody],mbody);
+    MathExtra::matvec (ex_space[ibody],ey_space[ibody],ez_space[ibody],
+                       mbody,angmom[ibody]);
+
+    angmom[ibody][0] *= 0.5;
+    angmom[ibody][1] *= 0.5;
+    angmom[ibody][2] *= 0.5;
+
+    MathExtra::angmom_to_omega (angmom[ibody],ex_space[ibody],ey_space[ibody],
+                                ez_space[ibody],inertia[ibody],omega[ibody]);
+  }
+
+  // virial setup before call to set_xv
+
+  if (vflag) v_setup(vflag);
+  else evflag = 0;
+
+  // set coords/orient and velocity/rotation of atoms in rigid bodies
+  // from quarternion and omega
+
+  set_xv();
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidSPH::final_integrate() {
+  int i,ibody;
+  double dtfm,xy,xz,yz;
+  double mbody[3],tbody[3],fquat[4];
+
+  double dtf2 = dtf * 2.0;
+
+  // sum over atoms to get force and torque on rigid body
+
+  double **x = atom->x;
+  double **f = atom->f;
+  int nlocal = atom->nlocal;
+
+  double xprd = domain->xprd;
+  double yprd = domain->yprd;
+  double zprd = domain->zprd;
+  if (triclinic) {
+    xy = domain->xy;
+    xz = domain->xz;
+    yz = domain->yz;
+  }
+
+  int xbox,ybox,zbox;
+  double xunwrap,yunwrap,zunwrap,dx,dy,dz;
+  for (ibody = 0; ibody < nbody; ibody++)
+    for (i = 0; i < 6; i++) sum[ibody][i] = 0.0;
+
+  for (i = 0; i < nlocal; i++) {
+    if (body[i] < 0) continue;
+    ibody = body[i];
+
+    sum[ibody][0] += f[i][0];
+    sum[ibody][1] += f[i][1];
+    sum[ibody][2] += f[i][2];
+
+    xbox = (xcmimage[i] & IMGMASK) - IMGMAX;
+    ybox = (xcmimage[i] >> IMGBITS & IMGMASK) - IMGMAX;
+    zbox = (xcmimage[i] >> IMG2BITS) - IMGMAX;
+
+    if (triclinic == 0) {
+      xunwrap = x[i][0] + xbox*xprd;
+      yunwrap = x[i][1] + ybox*yprd;
+      zunwrap = x[i][2] + zbox*zprd;
+    } else {
+      xunwrap = x[i][0] + xbox*xprd + ybox*xy + zbox*xz;
+      yunwrap = x[i][1] + ybox*yprd + zbox*yz;
+      zunwrap = x[i][2] + zbox*zprd;
+    }
+
+    dx = xunwrap - xcm[ibody][0];
+    dy = yunwrap - xcm[ibody][1];
+    dz = zunwrap - xcm[ibody][2];
+
+    sum[ibody][3] += dy*f[i][2] - dz*f[i][1];
+    sum[ibody][4] += dz*f[i][0] - dx*f[i][2];
+    sum[ibody][5] += dx*f[i][1] - dy*f[i][0];
+  }
+
+  // extended particles add their torque to torque of body
+
+  if (extended) {
+    // TBD
+  }
+
+  MPI_Allreduce (sum[0],all[0],6*nbody,MPI_DOUBLE,MPI_SUM,world);
+
+  // update vcm and angmom
+  // include Langevin thermostat forces
+  // fflag,tflag = 0 for some dimensions in 2d
+
+  for (ibody = 0; ibody < nbody; ibody++) {
+    fcm[ibody][0] = all[ibody][0];
+    fcm[ibody][1] = all[ibody][1];
+    fcm[ibody][2] = all[ibody][2];
+    torque[ibody][0] = all[ibody][3];
+    torque[ibody][1] = all[ibody][4];
+    torque[ibody][2] = all[ibody][5];
+
+    // update vcm by 1/2 step
+
+    dtfm = dtf / masstotal[ibody];
+
+    vcm[ibody][0] += dtfm * fcm[ibody][0] * fflag[ibody][0];
+    vcm[ibody][1] += dtfm * fcm[ibody][1] * fflag[ibody][1];
+    vcm[ibody][2] += dtfm * fcm[ibody][2] * fflag[ibody][2];
+
+    // update conjqm, then transform to angmom, set velocity again
+    // virial is already setup from initial_integrate
+
+    torque[ibody][0] *= tflag[ibody][0];
+    torque[ibody][1] *= tflag[ibody][1];
+    torque[ibody][2] *= tflag[ibody][2];
+
+    MathExtra::transpose_matvec (ex_space[ibody],ey_space[ibody],
+                                 ez_space[ibody],torque[ibody],tbody);
+    MathExtra::quatvec (quat[ibody],tbody,fquat);
+
+    conjqm[ibody][0] += dtf2 * fquat[0];
+    conjqm[ibody][1] += dtf2 * fquat[1];
+    conjqm[ibody][2] += dtf2 * fquat[2];
+    conjqm[ibody][3] += dtf2 * fquat[3];
+
+    MathExtra::invquatvec (quat[ibody],conjqm[ibody],mbody);
+    MathExtra::matvec (ex_space[ibody],ey_space[ibody],ez_space[ibody],
+                       mbody,angmom[ibody]);
+
+    angmom[ibody][0] *= 0.5;
+    angmom[ibody][1] *= 0.5;
+    angmom[ibody][2] *= 0.5;
+
+    MathExtra::angmom_to_omega (angmom[ibody],ex_space[ibody],ey_space[ibody],
+                                ez_space[ibody],inertia[ibody],omega[ibody]);
+  }
+
+  // set velocity/rotation of atoms in rigid bodies
+  // virial is already setup from initial_integrate
+
+  set_v();
+}
+
+/* ----------------------------------------------------------------------
+   set space-frame coords and velocity of each atom in each rigid body
+   set orientation and rotation of extended particles
+   x = Q displace + Xcm, mapped back to periodic box
+   v = Vcm + (W cross (x - Xcm))
+------------------------------------------------------------------------- */
+
+void FixRigidSPH::set_xv() {
+  int ibody;
+  int xbox,ybox,zbox;
+  double x0,x1,x2,v0,v1,v2,fc0,fc1,fc2,massone;
+  double xy,xz,yz;
+  double ione[3],exone[3],eyone[3],ezone[3],vr[6],p[3][3];
+
+  double **x = atom->x;
+  double **v = atom->v;
+  double **vest = atom->vest;
+  double **f = atom->f;
+  double *e = atom->e;
+  double *de = atom->de;
+  double *rho = atom->rho;
+  double *drho = atom->drho;
+  double *rmass = atom->rmass;
+  double *mass = atom->mass;
+  int *type = atom->type;
+  int nlocal = atom->nlocal;
+
+  double xprd = domain->xprd;
+  double yprd = domain->yprd;
+  double zprd = domain->zprd;
+
+  if (triclinic) {
+    xy = domain->xy;
+    xz = domain->xz;
+    yz = domain->yz;
+  }
+
+  // set x and v of each atom
+
+  for (int i = 0; i < nlocal; i++) {
+    if (body[i] < 0) continue;
+    
+    // half-step update of particle internal energy and density
+    e[i] += dtf * de[i];
+    rho[i] += dtf * drho[i];
+    
+    ibody = body[i];
+
+    xbox = (xcmimage[i] & IMGMASK) - IMGMAX;
+    ybox = (xcmimage[i] >> IMGBITS & IMGMASK) - IMGMAX;
+    zbox = (xcmimage[i] >> IMG2BITS) - IMGMAX;
+
+    // save old positions and velocities for virial
+
+    if (evflag) {
+      if (triclinic == 0) {
+        x0 = x[i][0] + xbox*xprd;
+        x1 = x[i][1] + ybox*yprd;
+        x2 = x[i][2] + zbox*zprd;
+      } else {
+        x0 = x[i][0] + xbox*xprd + ybox*xy + zbox*xz;
+        x1 = x[i][1] + ybox*yprd + zbox*yz;
+        x2 = x[i][2] + zbox*zprd;
+      }
+    }
+    
+    v0 = v[i][0];
+    v1 = v[i][1];
+    v2 = v[i][2];
+
+    // x = displacement from center-of-mass, based on body orientation
+    // v = vcm + omega around center-of-mass
+    // vest = 2*v - v_old
+
+    MathExtra::matvec (ex_space[ibody],ey_space[ibody],
+                       ez_space[ibody],displace[i],x[i]);
+
+    v[i][0] = omega[ibody][1]*x[i][2] - omega[ibody][2]*x[i][1] +
+      vcm[ibody][0];
+    v[i][1] = omega[ibody][2]*x[i][0] - omega[ibody][0]*x[i][2] +
+      vcm[ibody][1];
+    v[i][2] = omega[ibody][0]*x[i][1] - omega[ibody][1]*x[i][0] +
+      vcm[ibody][2];
+    
+    vest[i][0] = 2*v[i][0] - v0;
+    vest[i][1] = 2*v[i][1] - v1;
+    vest[i][2] = 2*v[i][2] - v2;
+
+    // add center of mass to displacement
+    // map back into periodic box via xbox,ybox,zbox
+    // for triclinic, add in box tilt factors as well
+
+    if (triclinic == 0) {
+      x[i][0] += xcm[ibody][0] - xbox*xprd;
+      x[i][1] += xcm[ibody][1] - ybox*yprd;
+      x[i][2] += xcm[ibody][2] - zbox*zprd;
+    } else {
+      x[i][0] += xcm[ibody][0] - xbox*xprd - ybox*xy - zbox*xz;
+      x[i][1] += xcm[ibody][1] - ybox*yprd - zbox*yz;
+      x[i][2] += xcm[ibody][2] - zbox*zprd;
+    }
+
+    // virial = unwrapped coords dotted into body constraint force
+    // body constraint force = implied force due to v change minus f external
+    // assume f does not include forces internal to body
+    // 1/2 factor b/c final_integrate contributes other half
+    // assume per-atom contribution is due to constraint force on that atom
+
+    if (evflag) {
+      if (rmass) massone = rmass[i];
+      else massone = mass[type[i]];
+      fc0 = massone*(v[i][0] - v0)/dtf - f[i][0];
+      fc1 = massone*(v[i][1] - v1)/dtf - f[i][1];
+      fc2 = massone*(v[i][2] - v2)/dtf - f[i][2];
+
+      vr[0] = 0.5*x0*fc0;
+      vr[1] = 0.5*x1*fc1;
+      vr[2] = 0.5*x2*fc2;
+      vr[3] = 0.5*x0*fc1;
+      vr[4] = 0.5*x0*fc2;
+      vr[5] = 0.5*x1*fc2;
+
+      v_tally(1,&i,1.0,vr);
+    }
+  }
+
+  // set orientation, omega, angmom of each extended particle
+
+  if (extended) {
+    // TBD
+  }
+}
+
+/* ----------------------------------------------------------------------
+   set space-frame velocity of each atom in a rigid body
+   set omega and angmom of extended particles
+   v = Vcm + (W cross (x - Xcm))
+------------------------------------------------------------------------- */
+
+void FixRigidSPH::set_v() {
+  int xbox,ybox,zbox;
+  double x0,x1,x2,v0,v1,v2,fc0,fc1,fc2,massone;
+  double xy,xz,yz;
+  double ione[3],exone[3],eyone[3],ezone[3],delta[3],vr[6];
+
+  double **x = atom->x;
+  double **v = atom->v;
+  double **f = atom->f;
+  double *e = atom->e;
+  double *de = atom->de;
+  double *rho = atom->rho;
+  double *drho = atom->drho;
+  double *rmass = atom->rmass;
+  double *mass = atom->mass;
+  int *type = atom->type;
+  int nlocal = atom->nlocal;
+
+  double xprd = domain->xprd;
+  double yprd = domain->yprd;
+  double zprd = domain->zprd;
+  if (triclinic) {
+    xy = domain->xy;
+    xz = domain->xz;
+    yz = domain->yz;
+  }
+
+  // set v of each atom
+
+  for (int i = 0; i < nlocal; i++) {
+    if (body[i] < 0) continue;
+    
+    // half-step update of particle internal energy and density
+    e[i] += dtf * de[i];
+    rho[i] += dtf * drho[i];
+    
+    const int ibody = body[i];
+
+    MathExtra::matvec (ex_space[ibody],ey_space[ibody],
+                       ez_space[ibody],displace[i],delta);
+
+    // save old velocities for virial
+
+    if (evflag) {
+      v0 = v[i][0];
+      v1 = v[i][1];
+      v2 = v[i][2];
+    }
+
+    v[i][0] = omega[ibody][1]*delta[2] - omega[ibody][2]*delta[1] +
+      vcm[ibody][0];
+    v[i][1] = omega[ibody][2]*delta[0] - omega[ibody][0]*delta[2] +
+      vcm[ibody][1];
+    v[i][2] = omega[ibody][0]*delta[1] - omega[ibody][1]*delta[0] +
+      vcm[ibody][2];
+
+    // virial = unwrapped coords dotted into body constraint force
+    // body constraint force = implied force due to v change minus f external
+    // assume f does not include forces internal to body
+    // 1/2 factor b/c initial_integrate contributes other half
+    // assume per-atom contribution is due to constraint force on that atom
+
+    if (evflag) {
+      if (rmass) massone = rmass[i];
+      else massone = mass[type[i]];
+      fc0 = massone*(v[i][0] - v0)/dtf - f[i][0];
+      fc1 = massone*(v[i][1] - v1)/dtf - f[i][1];
+      fc2 = massone*(v[i][2] - v2)/dtf - f[i][2];
+
+      xbox = (xcmimage[i] & IMGMASK) - IMGMAX;
+      ybox = (xcmimage[i] >> IMGBITS & IMGMASK) - IMGMAX;
+      zbox = (xcmimage[i] >> IMG2BITS) - IMGMAX;
+
+      if (triclinic == 0) {
+        x0 = x[i][0] + xbox*xprd;
+        x1 = x[i][1] + ybox*yprd;
+        x2 = x[i][2] + zbox*zprd;
+      } else {
+        x0 = x[i][0] + xbox*xprd + ybox*xy + zbox*xz;
+        x1 = x[i][1] + ybox*yprd + zbox*yz;
+        x2 = x[i][2] + zbox*zprd;
+      }
+
+      vr[0] = 0.5*x0*fc0;
+      vr[1] = 0.5*x1*fc1;
+      vr[2] = 0.5*x2*fc2;
+      vr[3] = 0.5*x0*fc1;
+      vr[4] = 0.5*x0*fc2;
+      vr[5] = 0.5*x1*fc2;
+
+      v_tally(1,&i,1.0,vr);
+    }
+  }
+
+  // set omega, angmom of each extended particle
+
+  if (extended) {
+    // TBD
+  }
+}
diff -Naur lammps-13Aug16/src/USER-SDPD/fix_rigid_sph.h lammps-13Aug16-sdpd/src/USER-SDPD/fix_rigid_sph.h
--- lammps-13Aug16/src/USER-SDPD/fix_rigid_sph.h	1970-01-01 03:30:00.000000000 +0330
+++ lammps-13Aug16-sdpd/src/USER-SDPD/fix_rigid_sph.h	2016-09-15 11:44:33.797845000 +0430
@@ -0,0 +1,67 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+
+FixStyle(rigid/sph,FixRigidSPH)
+
+#else
+
+#ifndef LMP_FIX_RIGID_SPH_H
+#define LMP_FIX_RIGID_SPH_H
+
+#include "fix_rigid.h"
+
+namespace LAMMPS_NS {
+
+class FixRigidSPH : public FixRigid {
+ public:
+  FixRigidSPH (class LAMMPS *, int, char **);
+  ~FixRigidSPH();
+  int setmask();
+  void setup(int);
+  void initial_integrate(int);
+  void final_integrate();
+
+ protected:
+  void set_xv();
+  void set_v();
+  double **conjqm;                    // conjugate quaternion momentum
+};
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: fix rigid/sph command requires atom_style with both energy and density
+
+You should use atom_style meso with this fix
+
+E: Can not use thermostat with fix rigid/sph
+
+Self-explanatory
+
+E: Can not use barostat with fix rigid/sph
+
+Self-explanatory
+
+E: Illegal ... command
+
+Self-explanatory.  Check the input script syntax and compare to the
+documentation for the command.  You can use -echo screen as a
+command-line option when running LAMMPS to see the offending line.
+
+*/
diff -Naur lammps-13Aug16/src/USER-SDPD/Install.sh lammps-13Aug16-sdpd/src/USER-SDPD/Install.sh
--- lammps-13Aug16/src/USER-SDPD/Install.sh	1970-01-01 03:30:00.000000000 +0330
+++ lammps-13Aug16-sdpd/src/USER-SDPD/Install.sh	2016-09-15 01:15:17.613365000 +0430
@@ -0,0 +1,30 @@
+# Install/unInstall package files in LAMMPS
+# mode = 0/1/2 for uninstall/install/update
+
+mode=$1
+
+# arg1 = file, arg2 = file it depends on
+
+action () {
+  if (test $mode = 0) then
+    rm -f ../$1
+  elif (! cmp -s $1 ../$1) then
+    if (test -z "$2" || test -e ../$2) then
+      cp $1 ..
+      if (test $mode = 2) then
+        echo "  updating src/$1"
+      fi
+    fi
+  elif (test ! -n "$2") then
+    if (test ! -e ../$2) then
+      rm -f ../$1
+    fi
+  fi
+}
+
+action pair_sdpd_taitwater_isothermal.cpp atom_vec_meso.cpp
+action pair_sdpd_taitwater_isothermal.h atom_vec_meso.cpp
+action fix_rigid_sph.cpp fix_rigid.cpp
+action fix_rigid_sph.h fix_rigid.cpp
+action fix_move_sph.cpp atom_vec_meso.cpp
+action fix_move_sph.h atom_vec_meso.h
diff -Naur lammps-13Aug16/src/USER-SDPD/pair_sdpd_taitwater_isothermal.cpp lammps-13Aug16-sdpd/src/USER-SDPD/pair_sdpd_taitwater_isothermal.cpp
--- lammps-13Aug16/src/USER-SDPD/pair_sdpd_taitwater_isothermal.cpp	1970-01-01 03:30:00.000000000 +0330
+++ lammps-13Aug16-sdpd/src/USER-SDPD/pair_sdpd_taitwater_isothermal.cpp	2016-08-19 00:18:19.631674000 +0430
@@ -0,0 +1,299 @@
+/* ----------------------------------------------------------------------
+ LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+ http://lammps.sandia.gov, Sandia National Laboratories
+ Steve Plimpton, sjplimp@sandia.gov
+
+ Copyright (2003) Sandia Corporation.  Under the terms of Contract
+ DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+ certain rights in this software.  This software is distributed under
+ the GNU General Public License.
+
+ See the README file in the top-level LAMMPS directory.
+ ------------------------------------------------------------------------- */
+
+#include <math.h>
+#include <stdlib.h>
+#include "pair_sdpd_taitwater_isothermal.h"
+#include "atom.h"
+#include "force.h"
+#include "comm.h"
+#include "neigh_list.h"
+#include "memory.h"
+#include "error.h"
+#include "domain.h"
+#include "update.h"
+#include "random_mars.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+PairSDPDTaitwaterIsothermal::PairSDPDTaitwaterIsothermal (LAMMPS *lmp) : Pair (lmp) {
+  restartinfo = 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+PairSDPDTaitwaterIsothermal::~PairSDPDTaitwaterIsothermal () {
+  if (allocated) {
+    memory->destroy (setflag);
+    memory->destroy (cutsq);
+
+    memory->destroy (cut);
+    memory->destroy (rho0);
+    memory->destroy (soundspeed);
+    memory->destroy (B);
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void PairSDPDTaitwaterIsothermal::compute (int eflag, int vflag) {
+  int i, j, ii, jj, inum, jnum, itype, jtype;
+  double xtmp, ytmp, ztmp, delx, dely, delz, fpair;
+
+  int *ilist, *jlist, *numneigh, **firstneigh;
+  double vxtmp, vytmp, vztmp, imass, jmass, fi, fj, fvisc, h, ih, ihsq, velx, vely, velz;
+  double rsq, tmp, wfd, delVdotDelR, deltaE;
+
+  if (eflag || vflag) ev_setup (eflag, vflag);
+  else evflag = vflag_fdotr = 0;
+
+  double **v = atom->vest;
+  double **x = atom->x;
+  double **f = atom->f;
+  double *rho = atom->rho;
+  double *mass = atom->mass;
+  double *de = atom->de;
+  double *drho = atom->drho;
+  int *type = atom->type;
+  int nlocal = atom->nlocal;
+  int newton_pair = force->newton_pair;
+  int dimension = domain->dimension;
+  double dtinv = 1.0 / update->dt;
+  double kBoltzmann = force->boltz;
+
+  inum = list->inum;
+  ilist = list->ilist;
+  numneigh = list->numneigh;
+  firstneigh = list->firstneigh;
+
+  // loop over neighbors of my atoms
+
+  for (ii = 0; ii < inum; ii++) {
+    i = ilist[ii];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    vxtmp = v[i][0];
+    vytmp = v[i][1];
+    vztmp = v[i][2];
+    itype = type[i];
+    jlist = firstneigh[i];
+    jnum = numneigh[i];
+
+    imass = mass[itype];
+
+    // compute pressure of atom i with Tait EOS
+    tmp = rho[i] / rho0[itype];
+    fi = tmp * tmp * tmp;
+    fi = B[itype] * (fi * fi * tmp - 1.0) / (rho[i] * rho[i]);
+
+    for (jj = 0; jj < jnum; jj++) {
+      j = jlist[jj];
+      j &= NEIGHMASK;
+
+      delx = xtmp - x[j][0];
+      dely = ytmp - x[j][1];
+      delz = ztmp - x[j][2];
+      rsq = delx * delx + dely * dely + delz * delz;
+      jtype = type[j];
+      jmass = mass[jtype];
+
+      if (rsq < cutsq[itype][jtype]) {
+        h = cut[itype][jtype];
+        ih = 1.0 / h;
+        ihsq = ih * ih;
+
+        double r = sqrt (rsq);
+        wfd = h - r;
+        if (dimension == 3) {
+          // Lucy Kernel, 3d
+          // Note that wfd, the derivative of the weight function with respect to r,
+          // is lacking a factor of r.
+          // The missing factor of r is recovered by
+          // (1) using delV . delX instead of delV . (delX/r) and
+          // (2) using f[i][0] += delx * fpair instead of f[i][0] += (delx/r) * fpair
+          wfd = -25.066903536973515383e0 * wfd * wfd * ihsq * ihsq * ihsq * ih;
+        } else {
+          // Lucy Kernel, 2d
+          wfd = -19.098593171027440292e0 * wfd * wfd * ihsq * ihsq * ihsq;
+        }
+
+        // compute pressure  of atom j with Tait EOS
+        tmp = rho[j] / rho0[jtype];
+        fj = tmp * tmp * tmp;
+        fj = B[jtype] * (fj * fj * tmp - 1.0) / (rho[j] * rho[j]);
+
+        velx=vxtmp - v[j][0];
+        vely=vytmp - v[j][1];
+        velz=vztmp - v[j][2];
+
+        // dot product of velocity delta and distance vector
+        delVdotDelR = delx * velx + dely * vely + delz * velz;
+
+        // Espanol Viscosity (Espanol, 2003)
+
+        fvisc = viscosity * imass * jmass * wfd * (1/rho[i]/rho[i] + 1/rho[j]/rho[j]);
+
+        // total pair force
+        fpair = -imass * jmass * (fi + fj) * wfd;
+
+        // random force calculation
+        // independent increments of a Wiener process matrix
+        double wiener[3][3] = {0};
+        for (int i=0; i<dimension; ++i) for (int j=0; j<dimension; ++j)
+          wiener[i][j] = random->gaussian ();
+        
+        // symmetric part
+        wiener[0][1] = wiener[1][0] = (wiener[0][1] + wiener[1][0]) / 2.;
+        wiener[0][2] = wiener[2][0] = (wiener[0][2] + wiener[2][0]) / 2.;
+        wiener[1][2] = wiener[2][1] = (wiener[1][2] + wiener[2][1]) / 2.;
+        
+        // traceless part
+        double trace_over_dim = (wiener[0][0] + wiener[1][1] + wiener[2][2]) / dimension;
+        wiener[0][0] -= trace_over_dim;
+        wiener[1][1] -= trace_over_dim;
+        wiener[2][2] -= trace_over_dim;
+        
+        double prefactor = sqrt (-4. * kBoltzmann*temperature * fvisc * dtinv) / r;
+//         printf ("%f\n", prefactor);
+        double f_random[3] = {0};
+        for (int i=0; i<dimension; ++i)
+          f_random[i] = prefactor * (wiener[i][0]*delx + wiener[i][1]*dely + wiener[i][2]*delz);
+        
+        f[i][0] += delx * fpair + velx * fvisc + f_random[0];
+        f[i][1] += dely * fpair + vely * fvisc + f_random[1];
+        f[i][2] += delz * fpair + velz * fvisc + f_random[2];
+
+        // and change in density
+        drho[i] += jmass * delVdotDelR * wfd;
+
+        if (newton_pair || j < nlocal) {
+          f[j][0] -= delx * fpair + velx * fvisc + f_random[0];
+          f[j][1] -= dely * fpair + vely * fvisc + f_random[1];
+          f[j][2] -= delz * fpair + velz * fvisc + f_random[2];
+          drho[j] += imass * delVdotDelR * wfd;
+        }
+
+        if (evflag)
+          ev_tally (i, j, nlocal, newton_pair, 0.0, 0.0, fpair, delx, dely, delz);
+      }
+    }
+  }
+
+  if (vflag_fdotr) virial_fdotr_compute ();
+}
+
+/* ----------------------------------------------------------------------
+ allocate all arrays
+ ------------------------------------------------------------------------- */
+
+void PairSDPDTaitwaterIsothermal::allocate () {
+  allocated = 1;
+  int n = atom->ntypes;
+
+  memory->create (setflag, n + 1, n + 1, "pair:setflag");
+  for (int i = 1; i <= n; i++)
+    for (int j = i; j <= n; j++)
+      setflag[i][j] = 0;
+
+  memory->create (cutsq, n + 1, n + 1, "pair:cutsq");
+
+  memory->create (rho0, n + 1, "pair:rho0");
+  memory->create (soundspeed, n + 1, "pair:soundspeed");
+  memory->create (B, n + 1, "pair:B");
+  memory->create (cut, n + 1, n + 1, "pair:cut");
+}
+
+/* ----------------------------------------------------------------------
+ global settings
+ ------------------------------------------------------------------------- */
+
+void PairSDPDTaitwaterIsothermal::settings (int narg, char **arg) {
+  if (narg != 2 && narg != 3) error->all (FLERR, "Illegal number of setting "
+    "arguments for pair_style sdpd/taitwater/morris/isothermal");
+  
+  temperature = force->numeric (FLERR, arg[0]);
+  viscosity = force->numeric (FLERR, arg[1]);
+  
+  if (temperature <= 0) error->all (FLERR, "Temperature must be positive");
+  if (viscosity <= 0) error->all (FLERR, "Viscosity must be positive");
+  
+  // seed is immune to underflow/overflow because it is unsigned
+  seed = comm->nprocs + comm->me + atom->nlocal;
+  if (narg == 3) seed += force->inumeric (FLERR, arg[2]);
+  random = new RanMars (lmp, seed);
+}
+
+/* ----------------------------------------------------------------------
+ set coeffs for one or more type pairs
+ ------------------------------------------------------------------------- */
+
+void PairSDPDTaitwaterIsothermal::coeff (int narg, char **arg) {
+  if (narg != 5) error->all (FLERR, "Incorrect args for pair_style "
+    "sph/taitwater/morris coefficients");
+  
+  if (!allocated) allocate();
+
+  int ilo, ihi, jlo, jhi;
+  force->bounds (arg[0], atom->ntypes, ilo, ihi);
+  force->bounds (arg[1], atom->ntypes, jlo, jhi);
+
+  double rho0_one = force->numeric (FLERR,arg[2]);
+  double soundspeed_one = force->numeric (FLERR,arg[3]);
+  double cut_one = force->numeric (FLERR,arg[4]);
+  double B_one = soundspeed_one * soundspeed_one * rho0_one / 7.0;
+  
+  if (rho0_one <= 0) error->all (FLERR, "Density must be positive");
+  if (soundspeed_one <= 0) error->all (FLERR, "Sound speed must be positive");
+  if (cut_one <= 0) error->all (FLERR, "Cutoff must be positive");
+
+  int count = 0;
+  for (int i = ilo; i <= ihi; i++) {
+    rho0[i] = rho0_one;
+    soundspeed[i] = soundspeed_one;
+    B[i] = B_one;
+    for (int j = MAX(jlo,i); j <= jhi; j++) {
+      cut[i][j] = cut_one;
+
+      setflag[i][j] = 1;
+      count++;
+    }
+  }
+
+  if (count == 0)
+    error->all(FLERR,"Incorrect args for pair coefficients");
+}
+
+/* ----------------------------------------------------------------------
+ init for one type pair i,j and corresponding j,i
+ ------------------------------------------------------------------------- */
+
+double PairSDPDTaitwaterIsothermal::init_one(int i, int j) {
+  if (setflag[i][j] == 0) 
+    error->all(FLERR,"Not all pair sph/taitwater/morris coeffs are not set");
+
+  cut[j][i] = cut[i][j];
+
+  return cut[i][j];
+}
+
+/* ---------------------------------------------------------------------- */
+
+double PairSDPDTaitwaterIsothermal::single (int, int, int, int,
+    double, double, double, double &fforce) {
+  fforce = 0.0;
+
+  return 0.0;
+}
diff -Naur lammps-13Aug16/src/USER-SDPD/pair_sdpd_taitwater_isothermal.h lammps-13Aug16-sdpd/src/USER-SDPD/pair_sdpd_taitwater_isothermal.h
--- lammps-13Aug16/src/USER-SDPD/pair_sdpd_taitwater_isothermal.h	1970-01-01 03:30:00.000000000 +0330
+++ lammps-13Aug16-sdpd/src/USER-SDPD/pair_sdpd_taitwater_isothermal.h	2016-08-18 21:58:23.604879000 +0430
@@ -0,0 +1,51 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+
+PairStyle(sdpd/taitwater/isothermal,PairSDPDTaitwaterIsothermal)
+
+#else
+
+#ifndef LMP_PAIR_SDPD_TAITWATER_MORRIS_ISOTHERMAL_H
+#define LMP_PAIR_SDPD_TAITWATER_MORRIS_ISOTHERMAL_H
+
+#include "pair.h"
+
+namespace LAMMPS_NS {
+
+class PairSDPDTaitwaterIsothermal : public Pair {
+ public:
+  PairSDPDTaitwaterIsothermal (class LAMMPS *);
+  virtual ~PairSDPDTaitwaterIsothermal ();
+  virtual void compute (int, int);
+  void settings (int, char **);
+  void coeff (int, char **);
+  virtual double init_one (int, int);
+  virtual double single (int, int, int, int, double, double, double, double &);
+
+ protected:
+  double viscosity, temperature;
+  double *rho0, *soundspeed, *B;
+  double **cut;
+
+  void allocate();
+  
+  unsigned int seed;
+  class RanMars *random;
+};
+
+}
+
+#endif
+#endif
